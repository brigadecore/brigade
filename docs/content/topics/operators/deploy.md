---
title: Deployment
description: How to deploy and manage Brigade
section: operators
weight: 1
aliases:
  - /deploy.md
  - /topics/deploy.md
  - /topics/operators/deploy.md
---

# Deploying and managing Brigade

In this doc, we'll go over steps for setting up and managing a
production-grade Brigade deployment.  This includes:

  - [Configuring passwords](#configuring-passwords)
  - [Certificates and TLS](#certificates-and-tls)
  - [Managing external access to Brigade via an ingress resource](#managing-inbound-traffic-via-ingress)
  - [Choosing a third-party authentication provider for managing user auth](#third-party-authentication)

(Alternatively, if you're interested in trying Brigade in a private and/or local development
environment, take a look at the [QuickStart].)

[QuickStart]: /intro/quickstart.md

## Prerequisites

* A [Kubernetes cluster], version 1.16+.
  Your cluster must be accessible to the outside world, e.g. to source(s) of
  event triggers (gateways) and to browsers for authentication callbacks.
  As long as the cluster is able to provision a public ip address, as any
  cloud provider's Kubernetes offering will support, you should be good to go.
* [Helm] v3.7.0+ installed.
* [kubectl] CLI installed.
* Free disk space on the cluster nodes.
  The installation requires sufficient free disk space and will fail if a
  cluster node disk is nearly full.

[Kubernetes cluster]: https://kubernetes.io/docs/setup/
[Helm]: https://helm.sh/docs/intro/install/
[kubectl]: https://kubernetes.io/docs/tasks/tools/#kubectl

## Prepping the Brigade 2 installation

For now, we're using the [GitHub Container Registry](https://ghcr.io) (which is
an [OCI registry](https://helm.sh/docs/topics/registries/)) to host our Helm
chart. Helm 3.7 has _experimental_ support for OCI registries. In the event that
the Helm 3.7 dependency proves troublesome for Brigade users, or in the event
that this experimental feature goes away, or isn't working like we'd hope, we
will revisit this choice before going GA.

First, let's set the necessary environment variable to enable this experimental
support and pull the Brigade chart to a local directory:

```console
$ export HELM_EXPERIMENTAL_OCI=1
```

You're now ready to view and edit configuration options:

```console
$ helm inspect values oci://ghcr.io/brigadecore/brigade-acr-gateway \
    --version v2.0.0-beta.3 > ~/brigade-values.yaml
```

In the next steps, we'll go through the configuration needed for a
production-grade deployment.

## Configuring passwords

In the Brigade chart values file (`brigade-values.yaml`) there are a few spots
where default passwords are used. It is recommended to supply your own values
for these fields. Here are the values to update and their locations in the
file:

  - The root user password at `apiserver.rootUser.password`
  - The MongoDB root user and database passwords at `mongodb.auth.rootPassword`
    and `mongodb.auth.password`
  - The Artemis user password at `artemis.password`

## Certificates and TLS

There are a handful of configuration options around certificates and TLS in
Brigade.  Here's a listing of each option as well as their locations in the
chart values file:

1. Disable TLS
    - Set `apiserver.tls.enabled` to `false`

2. Use self-signed certificates (auto-generated by the Helm chart)
    - No configuration needed (this is the default)

3. Add certificate and key material to the corresponding fields in the chart
   values file
    - Set `apiserver.tls.cert` to the certificate value
    - Set `apiserver.tls.key` to the key value
    - Set `apiserver.tls.generateSelfSignedCert` to `false`

4. Ensure the [Kubernetes Cert Secret] resource exists, either by creating it
   yourself or via another method (e.g. [Cert Manager] or another provider)
    - Set `apiserver.tls.generateSelfSignedCert` to `false`

For a production cluster, we highly recommend options 3 or 4.

[Kubernetes Cert Secret]: charts/brigade/templates/cert-secret.yaml
[Cert Manager]: https://cert-manager.io/docs/

## Managing inbound traffic via Ingress

By default, the Brigade chart configures the service type for the API server to
be `LoadBalancer`, which utilizes the cloud provider's infrastructure to
provision an external IP address. If this is suitable for your needs, you can
proceed to the next section.  After deployment of Brigade, you'll locate this
IP for the optional DNS record configuration.

Alternatively, you can configure an [Ingress resource] to be created when
Brigade is deployed. (We'll assume you've already selected an [Ingress
Controller] and deployed it to your Kubernetes cluster.)

DNS record creation will be mandatory when using Ingress, so be sure you have a
domain ready and you are able to create A records under this domain.

All configuration will go under the `apiserver` section of the chart values
file. Here's the breakdown of the relevant fields, with other nearby sections
omitted:

```yaml
apiserver:

  ## This is the DNS hostname you'll set up in a subsequent step
  ## For example, if you own the example.com domain and you create
  ## an A record for 'mybrigade', the host will be 'mybrigade.example.com'
  host: mybrigade.example.com

  ## Ensure tls is enabled for all Brigade's internal components
  ## For this example, we'll use self-signed certs
  tls:
    enabled: true
    generateSelfSignedCert: true

  ## Here's where we configure ingress
  ingress:
    enabled: true
    ## Annotations specific to the chosen ingress controller go here
    annotations:
    tls:
      enabled: true
      generateSelfSignedCert: false
      # cert: base 64 encoded cert goes here
      # key: base 64 encoded key goes here
```

Save your updates to `brigade-values2.yaml` and proceed to the next section.

[Ingress resource]: https://kubernetes.io/docs/concepts/services-networking/ingress/
[Ingress Controller]: https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/

## Third-Party Authentication

The default mode of authentication into Brigade, that of a root user and
password, is not suitable for a setup involving multiple users.

For production-grade user authentication, Brigade ships with support for
[OpenID Connect]-compatible providers (such as [Google Identity Platform] and
[Azure Active Directory]) or [GitHub].  In this doc, we'll configure GitHub to
be the auth provider.

[OpenID Connect]: https://openid.net/connect/
[Google Identity Platform]: https://cloud.google.com/identity-platform
[Azure Active Directory]: https://azure.microsoft.com/en-us/services/active-directory/
[GitHub]: https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps

### Configuring GitHub Authentication

Please see the [GitHub OAuth Provider] section of the [Authentication] doc for
setup and configuration.

After configuration is complete, save the updated file and proceed to the next
section.

[GitHub OAuth Provider]: /topics/administrators/authentication#github-oauth-provider
[Authentication]: /topics/administrators/authentication

## Additional configuration to consider

### Increasing volume size

Data volumes are used by both the backing data store and messaging queue
components, with implementations currently provided by MongoDB and Artemis,
respectively. For production deployments, it is recommended to increase the
size of both volumes.  As an example, Brigade's own CI/CD cluster is configured
with both volume sizes set to `40Gi`.

These values can be updated via the following two locations:

  - `mongodb.persistence.size`
  - `artemis.persistence.size`

## Deployment time!

Now that you have your `brigade-values.yaml` updated with your desired
configuration, you're ready to deploy!  Issue the following command, supplying
a dedicated Kubernetes namespace where all resources will be created and the
filepath to the chart values file you've updated and saved:

```console
$ helm install brigade \
    oci://ghcr.io/brigadecore/brigade \
    --version v2.0.0-beta.3 \
    --create-namespace \
    --namespace brigade \
    --values ~/brigade-values.yaml
```

You can issue the following `kubectl` command to monitor the status of the
deployments:

```console
$ kubectl rollout status deployment brigade-apiserver -n brigade --timeout 5m
```

### DNS hostname

Now that you have Brigade deployed, you're ready for DNS record creation.

If you haven't configured ingress for Brigade, you may choose to login via the
service IP directly, though it is highly recommended to create a DNS hostname
pointing to this IP instead.

To locate the IP, execute the following command:

```console
$ kubectl -n brigade get svc \
  -l app.kubernetes.io/name=brigade,app.kubernetes.io/component=apiserver \
  -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}'
```

(If you've configured ingress for Brigade, you'll use the external IP address
of the ingress controller instead.)

With the external IP address in hand, you're now ready to create the DNS entry.
With your DNS provider of choice, you'll create an [A record] mapping the
hostname on a domain you control to this IP address.  For example, if you
control the `example.com` domain and wish for the hostname for the Brigade
server to be `mybrigade.example.com`, create the DNS record with `mybrigade` as
the name, `A` as the record type and the external IP address captured
previously as the entry in the corresponding IP addresses section.

[A record]: https://www.cloudflare.com/learning/dns/dns-records/dns-a-record/

## Verifying deployment

Once all of the Kubernetes resources associated with Brigade are up and
running, you're ready to interact with Brigade.  You'll install the brig CLI and
verify TLS/cert setup, ingress and third-party auth, all via one command,
`brig login`.

### Installing the `brig` CLI

Next, download the appropriate, pre-built `brig` CLI (command line interface)
from our [releases page](https://github.com/brigadecore/brigade/releases) and
move it to any location on your path, such as `/usr/local/bin`, for instance.

### Logging In

Now you're ready to log in to Brigade!  For the server URL value, use the
hostname configured above (or external service IP directly).  Say the hostname
is `mybrigade.example.com`, the login command would then be:

```console
$ brig login --server https://mybrigade.example.com
```

This command will return a GitHub Oauth URL which you'll paste into the
browser of your choice to complete authentication.

_Note: you can also supply the `-b/--browse` flag if you'd like the default
browser to automatically open a page to the authentication callback URL
returned by the command._

On first login, the browser will navigate to a GitHub webpage requesting access
on behalf of the GitHub Oauth App to high-level, read-only access to your
GitHub user account (basically, to read your username and organization
associations).  Once approved, you should see a Brigade webpage confirming that
you are now logged in and ready to use the Brigade CLI.

## Wrap-up

Now that you have a production-ready Brigade server deployed using established
services for managing traffic, certificates and authentication, you're ready to
accept new users and transition focus to the Brigade system itself.

As all of the services, including Brigade itself, have been deployed by their
corresponding Helm charts, lifecycle management and configuration changes are
as easy as executing a `helm upgrade` command, either to bump to a more recent
chart version or to update release configuration.  For more details around
managing Helm releases, see [Helm's documentation].

[Helm's documentation]: https://helm.sh/docs/intro/using_helm

## Deploying multiple Brigade instances

It is possible to deploy multiple Brigade instances to one underlying
Kubernetes cluster. However, there is one piece of configuration necessary for
each Brigade instance other than the original. This is due to the global RBAC
resources that are created by the original deployment.

For each subsequent Brigade deployment, include the following configuration
in the chart values file:

```yaml
rbac:
  installGlobalResources: false
```

Then, deploy as usual!